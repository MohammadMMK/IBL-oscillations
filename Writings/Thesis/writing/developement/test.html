<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>test</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="test_files/libs/clipboard/clipboard.min.js"></script>
<script src="test_files/libs/quarto-html/quarto.js"></script>
<script src="test_files/libs/quarto-html/popper.min.js"></script>
<script src="test_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="test_files/libs/quarto-html/anchor.min.js"></script>
<link href="test_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="test_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="test_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="test_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="test_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="methods" class="level1">
<h1>Methods</h1>
<section id="data-source-and-recording-details" class="level2">
<h2 class="anchored" data-anchor-id="data-source-and-recording-details">Data source and recording details</h2>
<section id="international-brain-laboratory-ibl" class="level3">
<h3 class="anchored" data-anchor-id="international-brain-laboratory-ibl">International Brain Laboratory (IBL)</h3>
<p>We used the open-access dataset from the International Brain Laboratory (IBL). IBL provides a comprehensive set of recordings collected from more than 100 mice across 11 laboratories performing a standardized perceptual decision-making task. 547 Neuropixel probes were inserted in the left forebrain, midbrain, right hindbrain, and cerebellum to collect data on 267 brain regions <span class="citation" data-cites="benson2023">(<a href="#ref-benson2023" role="doc-biblioref">Benson et al. 2023</a>)</span> .</p>
</section>
<section id="task-detail" class="level3">
<h3 class="anchored" data-anchor-id="task-detail">Task detail</h3>
<p>In the IBL task (Figure 1), head-fixed mice had to move a visual stimulus to the center by turning a wheel with their front paws. At the start of each trial, the mouse was required to refrain from moving the wheel for a quiescence period lasting between 400 and 700 milliseconds. After this period, a visual stimulus (Gabor patch) appeared on either the left or right side of the screen accompanied by a 100-millisecond tone (5 kHz sine wave). If the mouse correctly moved the stimulus to the center by turning the wheel over 35°, it received a 3 µL water reward. Incorrect responses or failing to respond within 60 seconds resulted in a 500-millisecond burst of white noise and a timeout <span class="citation" data-cites="benson2023">(<a href="#ref-benson2023" role="doc-biblioref">Benson et al. 2023</a>)</span>. As shown in Figure 1c, mice typically responded quickly within 2 seconds. The stimulus is always presented for the first 1 second regardless of response time (RT).</p>
<p>The experiment began with 90 unbiased trials where the stimulus appeared equally on both sides. The stimulus contrast levels were presented in a ratio of [2:2:2:2:1] for contrasts [100%, 25%, 12.5%, 6%, 0%]. After this initial block, trials were organized into biased blocks where the likelihood of the stimulus appearing on one side was fixed at 20% for the left and 80% for the right in “right blocks” or vice versa in “left blocks.” These blocks consisted of 20 to 100 trials determined by a truncated geometric distribution with stimulus contrast levels ratio identical to those in the unbiased block. In 0% contrast trials where no stimulus was visible, the side assignment followed the block bias (e.g., right side for right blocks) <span class="citation" data-cites="benson2023">(<a href="#ref-benson2023" role="doc-biblioref">Benson et al. 2023</a>)</span>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Untitled%20(10).png" class="img-fluid figure-img" width="621"></p>
<figcaption><strong>a)</strong> Example session block diagram and IBL task. Each block of consecutive trials after 90 trials varied the probability of the stimulus being on the right side. <strong>B)</strong> A timeline of the main events and variables of the IBL task. After a quiescence period, stimulus appears on screen alongside a go cue tone. Mice had to bring the stimulus to the center by turning the wheel. When the wheel rotation reaches the threshold 35 ° or after 60 s of no response, positive or negative feedback is provided depending on the mice choice. (a) and (b) are extracted from <span class="citation" data-cites="Benson2023">(<a href="#ref-Benson2023" role="doc-biblioref"><strong>Benson2023?</strong></a>)</span>. <strong>C)</strong>&nbsp; Distribution of response time (RT) with color blue and stimulus offset with color yellow. RT is defined as the time after stimulus when the wheel rotation exceeds the threshold. Note that there is always a stimulus presented for 1 second even though the mice answer sooner&nbsp;</figcaption>
</figure>
</div>
</section>
<section id="electrophysiological-recording" class="level3">
<h3 class="anchored" data-anchor-id="electrophysiological-recording">Electrophysiological recording</h3>
<p>The neural recordings were conducted using Neuropixel 1.0 (3A or 3B) probes with 384 recording channels and 960 low-impedance sites on a single shank <span class="citation" data-cites="Benson2023">(<a href="#ref-Benson2023" role="doc-biblioref"><strong>Benson2023?</strong></a>)</span>. Neuropixel probes are advanced silicon-based neural recording devices designed for high-density recording of neural activity across large populations of neurons with precise spatial and temporal resolution <span class="citation" data-cites="jun2017">(<a href="#ref-jun2017" role="doc-biblioref">Jun et al. 2017</a>)</span>. After the recordings, electrode tracks were reconstructed by performing serial-section 2-photon microscopy. A region was then assigned to each recording site and neuron within the Allen Common Coordinate Framework <span class="citation" data-cites="Benson2023">(<a href="#ref-Benson2023" role="doc-biblioref"><strong>Benson2023?</strong></a>)</span>.</p>
</section>
</section>
<section id="preprocessing" class="level2">
<h2 class="anchored" data-anchor-id="preprocessing">Preprocessing</h2>
</section>
<section id="current-source-density-csd" class="level2">
<h2 class="anchored" data-anchor-id="current-source-density-csd">Current Source Density (CSD)</h2>
<p>To remove the effects of volume conduction on the LFP data and improve spatial resolution, we used Current Source Density (CSD) analysis. CSD is a technique that estimates the local current flow in the brain by calculating the second spatial derivative of the recorded potentials to reduce the influence of distant sources. First, the Euclidean distances between adjacent channels were computed using the channels’ location relative to the end of the probe (axial) and their location relative to the middle of the probe (lateral). The Euclidean distance between adjacent channels <span class="math inline">\(i\)</span> and <span class="math inline">\(i \pm 1\)</span> was calculated as:</p>
<p><span class="math display">\[
d_{i,i \pm 1} = \sqrt{(x_{i \pm 1} - x_i)^2 + (y_{i \pm 1} - y_i)^2}
\]</span></p>
<p>Where <span class="math inline">\(d_{i i \pm 1}\)</span> is the distance between channel <span class="math inline">\(i\)</span> and its adjacent channel <span class="math inline">\(i+1\)</span> (next channel) or <span class="math inline">\(i-1\)</span> (previous channel), <span class="math inline">\(x_i\)</span> and <span class="math inline">\(x_{i \pm 1}\)</span> are the axial coordinates of the channels, <span class="math inline">\(y_i\)</span> and <span class="math inline">\(y_{i \pm 1}\)</span> are the lateral coordinates.</p>
<p>Then the second spatial derivative of the LFP signals was computed as:</p>
<p><span class="math display">\[
CSD_i = \frac{V_{i+1} - V_i}{d_{i, i+1}^2} - \frac{V_i - V_{i-1}}{d_{i, i}^2}
\]</span></p>
<p>Here <span class="math inline">\(CSD_i\)</span> represents the current source density at channel <span class="math inline">\(i\)</span>, <span class="math inline">\(V_i\)</span> is the voltage at channel <span class="math inline">\(i\)</span>, <span class="math inline">\(V_{i+1}\)</span> and <span class="math inline">\(V_{i-1}\)</span> are the voltages at the adjacent channels <span class="math inline">\(i+1\)</span> and <span class="math inline">\(i-1\)</span> respectively.</p>
<p>In one-dimensional CSD analysis, it is typically assumed that channels are spaced uniformly (i.e., <span class="math inline">\(d_{i i+1} = d_{i i-1}\)</span>). However, in this project, we accounted for non-uniform spacing to enhance accuracy and enable the removal of noisy channels without risking the spread of artifacts to adjacent channels. The python script for CSD computation can be found in the “CSD_computation” Jupyter notebook in the GitHub repository.</p>
</section>
<section id="time-frequency-analysis" class="level2">
<h2 class="anchored" data-anchor-id="time-frequency-analysis">Time-Frequency Analysis</h2>
<p>For the time-frequency analysis, we chose the multitaper spectral method. This method is known to be well-suited for situations where specific frequency bands are not preselected and the goal is a broad exploration of all frequencies. Multitaper parameters were selected in a way where frequency resolution was prioritized very little over temporal resolution, especially at lower frequencies. In this regard, power and phase coherence were calculated using MNE’s multitaper function with the following parameters: a frequency range of 2-45 Hz with a step size of 0.5 Hz for the 2-10 Hz range and 1 Hz for frequencies above 10 Hz and a time-bandwidth product of 3.5 with the number of cycles at each frequency point set to half of the corresponding frequency (<span class="math inline">\(\text{n-cycles} = \frac{f}{2}\)</span>). These parameters were found to be optimal for our specific data and goals. A detailed comparison of different parameter settings can be found in the “tf_resolution” Jupyter notebook in the GitHub repository.</p>
</section>
<section id="phase-amplitude-coupling" class="level2">
<h2 class="anchored" data-anchor-id="phase-amplitude-coupling">Phase-Amplitude Coupling</h2>
<p>Phase-Amplitude Coupling (PAC) quantifies the interaction between the phase and amplitude of two distinct frequency bands, typically involving the phase of a low-frequency oscillation and the amplitude of a high-frequency oscillation. In this study, PAC was computed for phase frequencies ranging from 2 to 7 Hz and amplitude frequencies from 25 to 80 Hz using the TensorPAC Python module <span class="citation" data-cites="combrisson2020">(<a href="#ref-combrisson2020" role="doc-biblioref">Combrisson et al. 2020</a>)</span>. The process begins with the extraction of the instantaneous phase of the low-frequency signal and the amplitude envelope of the high-frequency signal carried out through a Morlet wavelet with a bandwidth parameter of 6. The interaction between these signals is then evaluated to determine how the phase of slower oscillations modulates the amplitude of faster oscillations. Several methods are available to quantify this coupling, including Mean Vector Length (MVL), Modulation Index (MI), Heights Ratio (HR), ndPAC, Phase-Locking Value (PLV), and Gaussian Copula (GC). Although there is no gold standard for choosing the best PAC method, MI, HR, and GC are recommended as they are robust to shifts in overall amplitude <span class="citation" data-cites="Combrisson2020">(<a href="#ref-Combrisson2020" role="doc-biblioref"><strong>Combrisson2020?</strong></a>)</span>. In this project, the GC method was employed to compute PAC for a time window spanning 500 ms before stimulus onset to 1 second after the stimulus.</p>
<p>The GC method works by leveraging the concept of copula theory to isolate the dependence structure between phase and amplitude signals independent of their marginal distributions. In this method, the phase is mapped onto the unit circle as a two-dimensional variable represented by the sine and cosine of the phase angle. Concurrently, the amplitude is transformed using a rank-based normalization which ensures that the measure is not influenced by the amplitude’s distribution. The core of the GC method involves calculating the mutual information between these transformed variables, quantifying the degree to which the phase of the low-frequency oscillation governs the amplitude of the high-frequency oscillation.</p>

</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-benson2023" class="csl-entry" role="listitem">
Benson, Brandon, Julius Benson, Daniel Birman, Niccolò Bonacchi, Matteo Carandini, Joana A Catarino, Gaelle A Chapuis, et al. 2023. <span>“A Brain-Wide Map of Neural Activity During Complex Behaviour.”</span> <em>bioRxiv</em>, January, 2023.07.04.547681. <a href="https://doi.org/10.1101/2023.07.04.547681">https://doi.org/10.1101/2023.07.04.547681</a>.
</div>
<div id="ref-combrisson2020" class="csl-entry" role="listitem">
Combrisson, Etienne, Timothy Nest, Andrea Brovelli, Robin A. A. Ince, Juan L. P. Soto, Aymeric Guillot, and Karim Jerbi. 2020. <span>“Tensorpac: An Open-Source Python Toolbox for Tensor-Based Phase-Amplitude Coupling Measurement in Electrophysiological Brain Signals.”</span> <em>PLOS Computational Biology</em> 16 (10): e1008302. <a href="https://doi.org/10.1371/journal.pcbi.1008302">https://doi.org/10.1371/journal.pcbi.1008302</a>.
</div>
<div id="ref-jun2017" class="csl-entry" role="listitem">
Jun, James J., Nicholas A. Steinmetz, Joshua H. Siegle, Daniel J. Denman, Marius Bauza, Brian Barbarits, Albert K. Lee, et al. 2017. <span>“Fully Integrated Silicon Probes for High-Density Recording of Neural Activity.”</span> <em>Nature</em> 551 (7679): 232–36. <a href="https://doi.org/10.1038/nature24636">https://doi.org/10.1038/nature24636</a>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>